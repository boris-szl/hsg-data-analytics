new;
cls;
format /rd 16,4;

// TASK 1
// we assign string name of the file to a variable
file = "DadesPAU.dat";

// open data via dataopen(...)
// return value of dataopen is a scalar
fh = dataopen(file,"read");

// get number of columns and rows for filehandle
ncol = colsf(fh);
nrow = rowsf(fh);
ncol; nrow;

// using loadd
// we load data and assign the return value of the function load(...) to X
// return value is a MxN matrix
X = loadd(file);

// For python .dat to .csv
call saved(X,"DadesPAU.csv");

// we define a variable headers and assign the column names of the dataset
headers = getHeaders(file);

// print headers and the first three rows
print headers;
print X[1:3,.];

dat_IQ = loadd(file,"IQ");
dat_HStudied = loadd(file,"HStudied");
dat_QualityHS = loadd(file,"QualityHS");
dat_Grade = loadd(file,"Grade");
length = rows(dat_IQ);

print "length at length/2" dat_IQ[length/2];

if fmod(length,2) == 0;
    print "true";
else;
    print "false";
endif;


print dat_IQ[1:3,.];
print dat_HStudied[1:3,.];

// descriptive statistics
vars = 0;
{ vnam, mean, var, std, min, max, valid, mis } = dstat(file, vars);
//or
call dstat(file);

// median
m = median(X); // we pass X as an argument because re
m;

// primitive way of doing this (I am sorry)
print "Median";
print "IQ" "\t" m[1,1];
print "HStudied" m[3,1];
print "Quality" "\t" m[3,1];
print "Grade\t" m[4,1];

// TASK 2
// Prerequisites: sorted list
// sort in gauss


// define procedure with median as output
// inputs are columns of the matrix X
// code below

m = median(dat_IQ);
print "Median of IQ:" m;
print "Median of IQ using procedure" ud_median(dat_IQ);
print "Median of IQ using alternative proc" ud_median_2(dat_IQ);
print "Median of IQ using alternative proc" ud_median_3(dat_IQ);
print "Median of IQ using alternative proc" ud_median_with_percentiles(dat_IQ);


fmod(50,2);

// the right one
// this works
proc(1) =  ud_median(column);
    local length, mdian, c;
    c = sortc(column);
    length = rows(c);
    if (fmod(length,2) == 0);
        mdian = 1/2*(c[length/2] + c[length/2+1]);
    else;
        mdian = c[(length+1)/2];
    endif;
    retp(mdian);
endp;

// alternative for large data sets
proc(1) = ud_median_2(column);
    local len, mdian, c;
    c = sortc(column);
    len = rows(c);
    if (fmod(len,2) == 0);
        mdian = c[len/2-1];
    else;
        mdian = 0;
    endif;
    retp(mdian);
endp;

proc(1) = ud_median_3(column);
    local len, mdian, c;
    c = sortc(column);
    len = rows(c);
    mdian = c[2*(len + 1)/4];
    retp(mdian);
endp;

proc(1) = ud_median_with_percentiles(column);
    local len,mdian,c;
    c = sortc(column);
    len = rows(c);
    mdian = c[50*(len/100)];
    retp(mdian);
endp;
    
// testing and comparions with output above


// TASK 3
// OLS
// endogenous variable := Grade
// exogenous variables := IQ, HStudied, Quality,
dep = "Grade";
string indep = {"IQ","HStudied","QualityHS"};
"\n";

// Specify the formula, 'Limit' is dependent variable
// and 'Balance', 'Income' and 'Age' are independent
// variables, '-1' means remove the intercept in the model
formula = "Grade ~ - 1 + IQ + HStudied + QualityHS";

// Call the OLS function
call ols(file, dep, indep);
"\n";
call ols(file, formula);

// TASK 4
// point estimator
// sort the data
// sort endog, exog variables
sorted_grade = dat_Grade;
y_endog = sorted_grade;

sorted_iq = dat_IQ;
sorted_hs = dat_HStudied;
sorted_qual = dat_QualityHS;

X[1:3,.];

X=loadd(file, "IQ+HStudied+QualityHS");
Y=loadd(file, "Grade");

first_comp = X'X;
inv(X'X)*X'Y;

beta_coeff =inv(X'X)*X'Y;
beta_coeff;


closeall fh;

end;


