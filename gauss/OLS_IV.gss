@ IV and OLS estimation 
The following features are added to the previous programme (OLS_IV.nodatfile.gss)
- Read and write data and predictions to and from file
- Provide descriptive statistics of predictions
- Provide plots of predictions
@
new; rndseed 12398764; cls; starttime = date;	// programme initialized

path_for_all = "Q:/SEW/Lechner/Veranstaltungen/HS20/Python and Gauss/Gauss/data/";

outputfile = "OLS_IV.out";	            // define output file to be used below
datafile   = "OLS_IV_data.dat";         // file used to contain data
predfile   = "OLS_IV_pred.dat";         // file used to save predictions

File_or_memory = 1;                     //1: Data stored in file; 0: Data stored in matrices
R = 1000;			                    // bootstrap replications

//Specify parameters of DGP
N = 20000;			                    // sample size 

//Coefficients
true_beta  = ones(4,1);				    // true coefficients
true_delta = -0.5;
//Variances of unobservables
sigma2_u   = 1;					        // true variance of error
sigma2_mu  = 1;					        // true variance of error in first stage of X4 on X3
//Covariates (independent variables)
dummy_p    = 0.8;                       // probability for dummy variable = 1
mean_x 	   = ones(2,1);                 // means of normally distributed covariates
sigma2_x   = eye(2);					// true variance covariance matrix of normally distributed covariates
sigma2_x[2,1] = 0.5;					// covariance
sigma2_x[1,2] = sigma2_x[2,1];          // covariance matrices are symetric

outputfile 	= path_for_all $+ outputfile;// adds correct path for file
datafile    = path_for_all $+ datafile; // adds correct path for file
predfile    = path_for_all $+ predfile;  // adds correct path for file

output file	=^outputfile reset;			// overwrites old output file of same name
"==============================================================================================";
"                    OLS and IV estimation - advanced version with data file";
"==============================================================================================";

//Generate artifical data (DGP1 & 2)
{y,x123,x4,y_name,x_name,z_name} = dgp_xy_file(N,true_beta,true_delta,dummy_p,sigma2_u,sigma2_mu,mean_x,sigma2_x,File_or_memory,datafile); // generate the data

//Descriptive statistics of input data
if File_or_memory;
    ?;
    "File used to store the data: ";; $datafile;
    call dstatmt(datafile);     //file with location of data passed
else;
    call dstatmt(0, y~x123~x4); //data passed as matrices, variables will automatically be labbeled X1,..., Xcols(matrix)
endif;    

//OLS estimation with matrices
if File_or_memory;
    b_ols = my_ols_xy_file(datafile,y_name,x_name,1);//OLS estimator using matrices
else;    
    b_ols = my_ols_xy(y,x123,1);//OLS estimator using matrices
endif;    

// We are not using the slow OLS part with loops, thus it has been deleted from the old file 

//Estimate IV, use matrices only
if File_or_memory;
    b_IV  = my_iv_xy_file(datafile,y_name,x_name, x_name[1 2] | z_name,1);
else;    
    b_IV  = my_iv_xy(y,x123,x123[.,1 2]~x4,1);
endif;

//Estimate standard errors
if File_or_memory;
    {b_ols_SE, b_ols_SE_boot} = bootstrap_ivols_std_xy_file(datafile,y_name,x_name,0,                   b_ols,r,"OLS",1);
    {b_iv_SE,  b_iv_SE_boot}  = bootstrap_ivols_std_xy_file(datafile,y_name,x_name,x_name[1 2] | z_name,b_IV, r,"IV" ,1);
else;    
    {b_ols_SE, b_ols_SE_boot} = bootstrap_ivols_std_xy(y,x123,0,             b_ols,r,"OLS",1);
    {b_iv_SE,  b_iv_SE_boot}  = bootstrap_ivols_std_xy(y,x123,x123[.,1 2]~x4,b_IV, r,"IV" ,1);
endif;
//Print results in useful format; also print CI of prediction
?;call estim_output(y_name,x_name,0,      b_ols,b_ols_SE,b_ols_SE_boot,N,R,"OLS",1);
?;call estim_output(y_name,x_name,z_name, b_iv, b_iv_SE, b_IV_SE_boot, N,R,"IV" ,1);

if File_or_memory; 
    ?;
    "File used to store the prediction: ";; $predfile;
    names_of_pred = save_predictions(datafile,predfile,x_name,b_ols,b_IV);
    call dstatmt(predfile);
    {pred,x2,_} = readdatafromfile_upto3vars(predfile,names_of_pred,x_name[2],"0"); //prediction for later use in plot
else;
    y_pred_ols = get_prediction(x123,b_ols);
    y_pred_IV  = get_prediction(x123,b_IV);
    call dstatmt(0,y_pred_ols~y_pred_IV~x123);
    pred = y_pred_ols ~ y_pred_IV;          //prediction for later use in plot
    x2 = x123[.,2];
endif;
mat=sortc(x2~pred,1);                        //sort variables, otherwise plot looks chaotic
call plotscatter(mat[.,1 1],mat[.,2 3]);     //very simple default plot; can be easily beautified --> user guide
plotOpenWindow;                              //next plot goes to new window,otherwise overrides previous plot
call plotxy(mat[.,1 1],mat[.,2 3]);          //very simple default plot; can be easily beautified --> user guide

call programmdauer(starttime); 		    // Duration of programme
end;										// End of programme

// Below follow some procedures 

proc(6)=dgp_xy_file(N,b,delta,dummy_p,sigma2_u,sigma2_mu,mean_x,sigma2_x,File_or_Memory,datafile);
	local y,x,x4,u,mu,x_name,z_name, fh;	
	x123 		= rndBernoulli(N,1,dummy_p) ~ rndMVn(N,mean_x,sigma2_x); //includes constant
	u 			= rndn(N,1) * sqrt(sigma2_u);
	mu			= rndn(N,1) * sqrt(sigma2_mu); 
	y 			= (ones(N,1)~x123)	* b + u;
	x4 			= x123[.,3] * delta + mu; 	
    y_name      = "y";
    x_name      = "x1" | "x2" | "x3";  
    z_name      = "x4";
    if File_or_memory;
        fh = datacreate(datafile,y_name $| x_name $| z_name, 0, 8, 1);      //create file
        call writer(fh,y~x123~x4);                                          //write data to file using its file handle
        fh = close(fh);                                                     //close file
        clear y,x123,x4;                                                    //set vars to zero: saves memory        
    endif;    
    ?;
    "Data generating process (DGP)";
    "True coefficients (beta):  ";; format /rds 5,3; b';
    "True coefficients (delta): ";; format 5,3; delta';
    "True E(X'U):               ";; format 5,3; meanc(x123 .* u)'; 
    "Sample size:               ";; format 5,0; N;
    retp(y,x123,x4,y_name,x_name, z_name);
endp;	

proc(1)=my_ols_xy_file(datafile,y_name,x_name,const);
    local b_est,y,x,_;
    {y,x,_} = readdatafromfile_upto3vars(datafile,y_name,x_name,"0");
    b_est = my_ols_xy(y,x,const);
    retp(b_est);
endp;    
    
proc(1)=my_iv_xy_file(datafile,y_name,x_name,z_name,const);
    local b_est,y,x,z;
    {y,x,z} = readdatafromfile_upto3vars(datafile,y_name,x_name,z_name);
    b_est = my_iv_xy(y,x,z,const);
    retp(b_est);
endp;    

proc(2)=bootstrap_ivols_std_xy_file(datafile,y_name,x_name,z_name,b_est,r,method,const);
    local b_SE,b_SE_boot,x,y,z,_;
    if method == "OLS";
        {y,x,_} = readdatafromfile_upto3vars(datafile,y_name,x_name,"0");
        z = 0;  //Not needed, set to arbitrary value to have it initialised
    else;    
        {y,x,z} = readdatafromfile_upto3vars(datafile,y_name,x_name,z_name);
    endif;    
    {b_SE, b_SE_boot} = bootstrap_ivols_std_xy(y,x,z,b_est, r,method ,const);
    retp(b_SE, b_SE_boot);
endp;

proc(3)=readdatafromfile_upto3vars(datafile,var_name1,var_name2,var_name3); //reads up to 3 sets of variables from Gauss data file
    local data,data1,data2,data3,data1_i,data2_i,data3_i,fh,N;        
    fh   = dataopen(datafile,"read");
    N    = rowsf(fh);           //number of rows in this data set
    data = readr(fh,N);         // reads all data in one go; could also be done sequentially   
    fh   = close(fh);           //close file
    if var_name1 $== "0";       //any usful content in var_name1  ?   
        "Nothing to read. Programme does not make sense."; 
        end;                            // terminate programme
    else;
        {var_name1,data1_i}  = indices(datafile,var_name1);    // gives column position of variable in data set
        data1    = data[.,data1_i];
    endif;    
    if var_name2 $== "0";         //any usful content in var_name2  ?        
        data2 = 0;
    else;
        {var_name2,data2_i}  = indices(datafile,var_name2);    // gives column position of variable in data set
        data2    = data[.,data2_i];
    endif;    
    if var_name3 $== "0";         //any usful content in var_name3  ?        
        data3 = 0;
    else;
        {var_name3,data3_i}  = indices(datafile,var_name3);    // gives column position of variable in data set
        data3    = data[.,data3_i];
    endif;    
    retp(data1,data2,data3);
endp;    

proc(1)=save_predictions(datafile,predfile,x_name,b_ols,b_IV);
    local fh,_,pred_names, x;
    {x,_,_} = readdatafromfile_upto3vars(datafile,x_name,"0","0");
    y_pred_ols = get_prediction(x,b_ols);
    y_pred_IV  = get_prediction(x,b_IV);
    pred_names = "ols_pred" | "iv_pred";
    fh = datacreate(predfile,pred_names | x_name, 0, 8, 1); //create file
    call writer(fh,y_pred_ols~y_pred_IV~x);     //write data to file using its file handle
    fh = close(fh);                           //close file
    retp(pred_names);
endp;

proc(1)=get_prediction(x,b_est);
    local pred;
    if cols(x) < rows(b_est);
        x = ones(rows(x), 1) ~ x;
    endif;
    pred = x * b_est;    
    retp(pred);
endp;

proc(1)=my_ols_xy(y,x,const);
	local b_est;
    if const;
        x = ones(rows(x),1) ~ x;    
    endif;    	
	b_est = invpd(x'x) * x'y;
	retp(b_est);
endp;

proc(1)=my_slow_ols_xy(y,x,const);
	local b_est,xTx,xTy,i;
	if const;
        x = ones(rows(x),1) ~ x;
    endif;    	
	xTx = zeros(cols(x),cols(x));
    xTy = zeros(cols(x),1);
    //do summation over observations and columns in loops
	for i(1,rows(x),1);
        for j(1,cols(x),1);
		    xTy[j] = xTy[j] + x[i,j] * y[i,1];
            for jj(1,cols(x),1);
               xTx[j,jj] = xTx[j,jj] + x[i,j] * x[i,jj];
            endfor;    
        endfor;    
	endfor;
	b_est = invpd(xTx) * xTy;    //use matrix operation, already slow enough ;-)
	retp(b_est);
endp;

proc(1)=my_iv_xy(y,x,z,const);
	local b;
    if const;
        x = ones(rows(x),1) ~ x;
        z = ones(rows(x),1) ~ z;
    endif;    
	b = inv(z'x) * z'y;  //inv instead of invpd as z'x is not positive definite
	retp(b);
endp;

proc(2)=bootstrap_ivols_std_xy(y,x,z,b_est,repl,method,const);
	local b_SE,b_SE_boot,i,b,bb,indi,indi_i,N,xx,zz,sigma2_est,x_dach,b_CV;    
    //Same procedure for OLS and IV as they are very simular
    N = rows(x);
    //Classical standard errors, homoscedasticity
    if rows(b_est) > cols(x);
        xx = ones(N,1)~x;
        if method $== "IV";    
            zz = ones(N,1)~z;
        endif; 
    else; //no constant term
        xx = x;
        if method $== "IV";    
            zz = z;
        endif; 
    endif;
    sigma2_est = sumc((y - xx * b_est).^2) / (N - cols(xx));
    if 		method $== "OLS";
        b_CV = sigma2_est * invpd(xx'xx);
    elseif 	method $== "IV";
        x_dach = zz*invpd(zz'zz)*zz'xx;
        b_CV = sigma2_est * invpd(x_dach'x_dach);
    else;
        "Unknown estimation method. Programme terminated.";
        end;
    endif;
    b_SE = sqrt(diag(b_CV));
    //Bootstrap standard errors
	b = zeros(r,cols(x)+const);
	for i(1,repl,1);		// loop over bootstraps			        
        indi_i = rndi(N,1,1|N);   //draw random indices with replacement of size N
		if 		method $== "OLS"; bb = my_ols_xy(y[indi_i,.],x[indi_i,.],const);
		elseif 	method $== "IV";  bb = my_iv_xy( y[indi_i,.],x[indi_i,.],z[indi_i,.],const);	
		endif;
		b[i,.] = bb';
	endfor;	
	b_SE_boot = stdc(b); //take descriptive stat's from bootstrap distribution of estimator
    retp(b_SE, b_SE_boot);
endp;

proc(0)=estim_output(dep_v,indep_v,inst_v,coef,SE,SE_boot,N,r,method,const);
	local i,t;
    if const;
        indep_v = "const" | indep_v; 
    endif;    
	t = coef ./ SE;
	"==============================================================================================";
	"Estimation output of " $method;; " estimation.  Sample size: ";; format /rds 4,0; N;
	" Bootstrap replications: ";; R;; "  Dependent variable: ";; format 8,8; $dep_v;
    if method $== "IV";
        "Name of instruments: ";;  $inst_v;
    endif;    
	"----------------------------------------------------------------------------------------------";
	"Variable    Coefficient    Std.Error    Std.E.Boot   t - value";
	for i(1,rows(indep_v),1);
		format 8,8; $indep_v[i];; format 12,3; coef[i];; SE[i];;  SE_boot[i];; t[i];	
	endfor;	
	"----------------------------------------------------------------------------------------------";
endp;

proc(0)=show_time_diff(ti1_a,ti1_e,text1,ti2_a,ti2_e,text2);	
    "----------------------------------------------------------------------------------------------";
	"Time needed for ";; text1;; ": ";;format 8,3; etstr_neu(ethsec(ti1_a,ti1_e));
	"Time needed for ";; text2;; ": ";;format 8,3; etstr_neu(ethsec(ti2_a,ti2_e));
	"Time difference 2 - 1:       ";;  format 8,3; etstr_neu(ethsec(ti2_a,ti2_e)-ethsec(ti1_a,ti1_e));
    "----------------------------------------------------------------------------------------------";
endp;
proc(0)=etstr_neu(hhsec);
    if hhsec < 1;
        format 8,5; hhsec/100;;" seconds";
    else;   
        etstr(hhsec);
    endif;    
endp;    

proc(0)=programmdauer(starttime);
	local endtime,hs;
	endtime = date;
	hs = ethsec(starttime, endtime); format 8,4;
	"===============================================";
	"Duration of programme was " etstr(hs);
	"===============================================";
endp;
